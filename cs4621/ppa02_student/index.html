<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: PPA2 -- Data Visualization</title>

    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<div class="container">
    <h1>CS 4621 PPA2 <span class="subtitle">Data Visualization</span></h1>

    <h2>Team Members</h2>
    <ul>
        <li><h3>Siyuan Wang(sw884)</h3></li>
    </ul>

    <div style="float:left; width: 70%">
        <div align="center" id="currentYear"></div>
        <div align="center">
            <canvas id="webglCanvas" style="border: none; background-color: whitesmoke;" width="800" height="800"></canvas>
        </div>
        <div>
            <table style="margin-top: 10px;">
                <tr>
                    <td>
                        <button id="playButton" class="btn btn-primary">Play!</button>
                    </td>
                    <td width="10"></td>
                    <td>
                        <table>
                            <tr>
                                <td width="720" id="yearSlider"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
            <table class="table table-bordered" style="margin-top: 10px;">
                <tr>
                    <td width="20%" style="vertical-align: middle">
                        <div>GDP per Capita Scale</div>
                    </td>
                    <td>
                        <select id="gdpPerCapitaScale" class="form-control">
                            <option value="Logarithm" selected="selected">Logarithm</option>
                            <option value="Linear">Linear</option>
                        </select>
                    </td>
                    <td width="20%" style="vertical-align: middle">
                        <div>Life Expectancy Scale</div>
                    </td>
                    <td>
                        <select id="lifeExpectancyScale" class="form-control">
                            <option value="Logarithm">Logarithm</option>
                            <option value="Linear" selected="selected">Linear</option>
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>
                        <div style="vertical-align: middle" id="bubbleScaleLabel">Population Scale</div>
                    </td>
                    <td>
                        <table>
                            <tr>
                                <td width="360" id="bubbleScaleSlider"></td>
                            </tr>
                        </table>
                    </td>
                    <td>
                        <div style="vertical-align: middle">Transparency</div>
                    </td>
                    <td>
                        <table>
                            <tr>
                                <td width="360" id="transparencySlider"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </div>
    </div>
    <div style="float:right; width: 29%">
        <h4 style="margin-top: 25%">Bubble Size Dataset Selection</h4>
        <select id="datasetSelection" class="form-control">
            <option value="Population" selected="selected">Population</option>
            <option value="Oil Consumption per Capita">Oil Consumption per Capita</option>
        </select>
        <h4>Cursor</h4>
        <table class="table table-bordered">
            <tr>
                <td>GDP per Capita ($)</td>
                <td id="gdpPerCapita" width="50%" ></td>
            </tr>
            <tr>
                <td>Life Expectancy (years)</td>
                <td id="lifeExpectancy" width="50%"></td>
            </tr>
        </table>
        <h4 style="margin-top: 5%">Data Point</h4>
        <table class="table table-bordered">
            <tr>
                <td>Country</td>
                <td id="country" width="50%"></td>
            </tr>
            <tr>
                <td>Year</td>
                <td id="year" width="50%"></td>
            </tr>
            <tr>
                <td id="bubbleLabel"></td>
                <td id="currentBubbleVal" width="50%"></td>
            </tr>
            <tr>
                <td>GDP per Capita ($)</td>
                <td id="gdpPerCapitaDataPoint" width="50%"></td>
            </tr>
            <tr>
                <td>Life Expectancy (years)</td>
                <td id="lifeExpectancyDataPoint" width="50%"></td>
            </tr>
        </table>
        <h4>Country List</h4>
        <div style="overflow-y: scroll; height: 350px;" id="countryCheckBoxes"></div>
        <!--<button id="selectAllButton" style="margin-top: 5%" class="btn btn-primary">Select All</button>-->
        <button id="deselectAllButton" style="margin-top: 5%" class="btn btn-danger">Deselect All</button>
    </div>
    <i id="cursor-tooltip" data-html="true" data-toggle="tooltip" data-placement="right" title="Tooltip for image" data-animation="false" data-trigger="manual" style="position: absolute"/>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/bootstrap.min.js"></script>

<!-- Data -->
<script src="data/country_list.js"></script>
<script src="data/population.js"></script>
<script src="data/oilConsumptionPerCapita.js"></script>
<script src="data/gdp_per_capita.js"></script>
<script src="data/life_expectancy.js"></script>
<script>
    var bubbleScaleSlider = $("#bubbleScaleSlider");
    var transparencySlider = $("#transparencySlider");

    bubbleScaleSlider.slider({
        min:1,
        max:100
    });
    transparencySlider.slider({
        min:1,
        max:100
    });
</script>

<script>
    // Year slider and the play button.
    var yearSlider = $("#yearSlider");
    var playButton = $("#playButton");

    yearSlider.slider({
        min: 1800,
        max: 2015
    });

    var isPlaying = false;
    var lastYearUpdate;
    var yearUpdateInterval = 100.0;

    function startPlay() {
        isPlaying = true;
        lastYearUpdate = performance.now();
        yearSlider.slider("disable");
        playButton.text("Stop!");
    }

    function stopPlay() {
        playButton.text("Play!");
        isPlaying = false;
        yearSlider.slider("enable");
    }

    playButton.click(function () {
        if (isPlaying) {
            stopPlay();
        } else {
            startPlay();
        }
    });

    function updateUi() {
        var year = yearSlider.slider("value");

        if (isPlaying) {
            if (year == 2015) {
                stopPlay();
            } else {
                var currentTime = performance.now();
                if (currentTime - lastYearUpdate > yearUpdateInterval) {
                    lastYearUpdate = currentTime;
                    yearSlider.slider("value", year + 1);
                }
            }
        }

        year = yearSlider.slider("value");
        $("#currentYear").html("<h1>" + year + "</h1>");

        $("#bubbleLabel").text($("#datasetSelection").val());
        $("#bubbleScaleLabel").text($("#datasetSelection").val() + " Scale");
        if ($("#datasetSelection").val() == "Population") {
            bubbleValues = getPopulation();
            baseYear = 1800;
            yearSlider.slider('option',{min: 1800, max: 2015});
        } else {
            bubbleValues = getOilConsumptionPerCapita();
            baseYear = 1965;
            yearSlider.slider('option',{min: 1965, max: 2010});
        }
        minBubbleValue = Math.min.apply(Math, flattenValue(bubbleValues));
        maxBubbleValue = Math.max.apply(Math, flattenValue(bubbleValues));

        window.requestAnimationFrame(updateUi);
    }
    window.requestAnimationFrame(updateUi);

    // Checkbox lists.
    var countries = getCountryList();

    var selectedCountries = [];

    function createCountryCheckBoxes() {
        var countryHtmls = [];
        var i;
        for(i=0;i<countries.length;i++) {
            var name = countries[i].name;
            countryHtmls.push("<input type='checkbox' value='" + name + "' id='checkBox" + i + "'> " + name + "<br>");
        }
        $("#countryCheckBoxes").html(countryHtmls.join(""));

        function setCheckBoxChangeFunction(i) {
            var checkBoxName = "checkBox" + i;
            var checkBox = $("#" + checkBoxName);
            var name = countries[i].name;
            checkBox.change(function() {
                var checked = checkBox.prop("checked");
                if (!checked) {
                    var index = selectedCountries.indexOf(name);
                    if (index > -1) {
                        selectedCountries.splice(index,1);
                    }
                } else {
                    selectedCountries.push(name);
                }
            });
        }

        for(i=0;i<countries.length;i++) {
            setCheckBoxChangeFunction(i);
        }
    }
    createCountryCheckBoxes();

    function addCountry(country) {
        var name = country.name;
        var index = countries.indexOf(country);
        if (index > -1) {
            var checkBoxName = "checkBox" + index;
            var checkBox = $("#" + checkBoxName);
            if (!checkBox.prop("checked")) {
                checkBox.prop("checked", true);
                selectedCountries.push(name);
            }
        }
    }

    function addCountryByName(countryName) {
        for (var i = 0; i < countries.length; i++) {
            if (countries[i].name == countryName) {
                addCountry(countries[i]);
                break;
            }
        }
    }

    function removeCountry(country) {
        var index = countries.indexOf(country);
        if (index > -1) {
            var checkBoxName = "checkBox" + index;
            var checkBox = $("#" + checkBoxName);
            if (checkBox.prop("checked")) {
                selectedCountries.splice(selectedCountries.indexOf(country.name), 1);
                checkBox.prop("checked", false);
            }
        }
    }

    function removeCountryByName(countryName) {
        for (var i = 0; i < countries.length; i++) {
            if (countries[i].name == countryName) {
                removeCountry(countries[i]);
                break;
            }
        }
    }

    $("#selectAllButton").click(function() {
        countries.forEach(addCountry);
    });

    $("#deselectAllButton").click(function() {
        countries.forEach(removeCountry);
    });
</script>
<script id="vertexShader" type="x-shader/x-vertex">
    #define SHAPE_COUNT 195
    precision highp float;

    uniform vec2 centers[SHAPE_COUNT];
    uniform float sizes[SHAPE_COUNT];
    uniform float regions[SHAPE_COUNT];
    uniform int useVertexPos;
    uniform int useHaloColor;
    uniform int useRegionOverride;
    uniform float regionOverride;

    attribute vec2 position;
    attribute float shapeIndex;
    attribute vec3 vert_position;

    varying float region;
    varying vec3 colorToUse;
    varying vec2 currPos;


    void main() {
        if (useVertexPos == 1) {
            gl_Position = vec4(vert_position, 1.0);
            if (useHaloColor == 1) {
                colorToUse = vec3(1.0,0.078,0.576);
            } else {
                colorToUse = vec3(0.0,0.0,0.0);
            }
            if (useRegionOverride == 1) {
                region = regionOverride;
            }
        } else {
            vec2 center = centers[int(shapeIndex)];
            float size = sizes[int(shapeIndex)];
            vec2 p = size*position + center;
            gl_Position = vec4(p, 0.0, 1.0);
            region = regions[int(shapeIndex)];
            currPos = position;
        }
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    #define SHAPE_COUNT 195
    precision highp float;

    varying float region;
    uniform float alpha;

    uniform int useSolid;
    varying vec3 colorToUse;
    varying vec2 currPos;

    void main() {
        if (useSolid == 1) {
            gl_FragColor = vec4(colorToUse, 1.0);
        } else {
            if (length(currPos) > 0.950) {
                gl_FragColor = vec4(0.0,0.0,0.0, alpha);
            } else {
                if (int(region) == 1) {
                    gl_FragColor = vec4(1.0,0.0,0.0, alpha);
                } else if (int(region) == 2) {
                    gl_FragColor = vec4(0.0,1.0,0.0, alpha);
                } else if (int(region) == 3) {
                    gl_FragColor = vec4(0.0,0.0,1.0, alpha);
                } else {
                    gl_FragColor = vec4(1.0,1.0,0.0, alpha);
                }
            }
        }
    }
</script>
<script>
    function initializeWebGL(canvasName) {
        var canvas = $("#" + canvasName);
        // Getting WebGL context the right way
        var gl = null;
        try {
            gl = canvas[0].getContext("experimental-webgl");
            if (!gl) {
                gl = canvas[0].getContext("webgl");
            }
        } catch (error) {
            // NO-OP
        }
        if (!gl) {
            alert("Could not get WebGL context!");
            throw new Error("Could not get WebGL context!");
        }
        return gl;
    }

    function createShader(gl, shaderScriptId) {
        var shaderScript = $("#" + shaderScriptId);
        var shaderSource = shaderScript[0].text;
        var shaderType = null;
        if (shaderScript[0].type == "x-shader/x-vertex") {
            shaderType = gl.VERTEX_SHADER;
        } else if (shaderScript[0].type == "x-shader/x-fragment") {
            shaderType = gl.FRAGMENT_SHADER;
        } else {
            throw new Error("Invalid shader type: " + shaderScript[0].type)
        }
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            var infoLog = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error("An error occurred compiling the shader: " + infoLog);
        } else {
            return shader;
        }
    }

    function createGlslProgram(gl, vertexShaderId, fragmentShaderId) {
        var program = gl.createProgram();
        gl.attachShader(program, createShader(gl, vertexShaderId));
        gl.attachShader(program, createShader(gl, fragmentShaderId));
        gl.linkProgram(program);
        gl.validateProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            var infoLog = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error("An error occurred linking the program: " + infoLog);
        } else {
            return program;
        }
    }

    var gl = initializeWebGL("webglCanvas");
    var program = createGlslProgram(gl, "vertexShader", "fragmentShader");

    var xLinearGridSize = 6;
    var yLinearGridSize = 5;
    var xLogGridSize = 3;
    var yLogGridSize = 2;
    var totalLineCount = 0;
    var cornerCount = 32;
    var circleVertexData = [];
    var circleIndexData = [];
    var gridVertexData = [];
    var haloVertexData = [];
    var highlightVertexData = [];
    var highlightIndexData = [];

    var currentYearSizes = [];
    var currentYearCenterX = [];
    var currentYearCenterY = [];
    var currentYearRegions = [];
    var allCircleData = [];

    var selectedCountrySizes = [];
    var selectedCountryCenterX = [];
    var selectedCountryCenterY = [];
    var selectedCountryRegions = [];

    var selectedCountryVertexData = [];
    var selectedCountryIndexData = [];

    var trendLineVertexData = [];
    var trendLineVerticesCounts = [];
    var trendLineRegionCodes = [];

    var highlightSizes = [];
    var highlightCenterX = [];
    var highlightCenterY = [];
    var highlightRegions = [];

    var gdpPerCapitas = getGdpPerCapita();
    var lifeExpectancies = getLifeExpectancy();
    var bubbleValues = $("#datasetSelection").val() == "Population" ? getPopulation() : getOilConsumptionPerCapita();
    var oilConsumptionsPerCapita = getOilConsumptionPerCapita();
    var countryList = getCountryList();
    var bubbleScaleSlider = $("#bubbleScaleSlider");
    var transparencySlider = $("#transparencySlider");
    bubbleScaleSlider.slider("value", 40);
    transparencySlider.slider("value", 70);
    var baseYear = 1800;

    function flattenValue(someMap) {
        var keys = Object.keys(someMap);
        var arrayOfValueArray = keys.map(function(t) { return someMap[t];});
        var falttenedArr = [].concat.apply([], arrayOfValueArray);
        return falttenedArr.filter(function(someVal){ return someVal != null });
    }
    var minGDP = Math.min.apply(Math, flattenValue(gdpPerCapitas));
    var maxGDP = Math.max.apply(Math, flattenValue(gdpPerCapitas));
    var minLifeExpectancy = Math.min.apply(Math, flattenValue(lifeExpectancies));
    var maxLifeExpectancy = Math.max.apply(Math, flattenValue(lifeExpectancies));
    var minBubbleValue = Math.min.apply(Math, flattenValue(bubbleValues));
    var maxBubbleValue = Math.max.apply(Math, flattenValue(bubbleValues));

    function gdpPerCapitaToScale(gdpPerCapita, isLinear){
        if (isLinear) {
            return ((gdpPerCapita-minGDP)/(maxGDP-minGDP))*2-1;
        } else {
            return ((Math.log10(gdpPerCapita) - Math.floor(Math.log10(minGDP)))/xLogGridSize)*2-1;
        }
    }

    function fromScaleToGdpPerCapita(xVal, isLinear) {
        if (isLinear) {
            return xVal*(maxGDP-minGDP) + minGDP;
        } else {
            return Math.pow(10, xVal*xLogGridSize + Math.floor(Math.log10(minGDP)));
        }
    }

    function lifeExpectancyToScale(lifeExpectancy, isLinear){
        if (isLinear) {
            return ((lifeExpectancy-minLifeExpectancy)/(maxLifeExpectancy-minLifeExpectancy))*2-1;
        } else {
            return (Math.log10(lifeExpectancy)/yLogGridSize)*2-1;
        }
    }

    function fromScaleToLifeExpectancy(yVal, isLinear) {
        if (isLinear) {
            return yVal*(maxLifeExpectancy-minLifeExpectancy) + minLifeExpectancy;
        } else {
            return Math.pow(10, yVal*yLogGridSize);
        }
    }

    function updateGridData() {
        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        gridVertexData = [];
        totalLineCount = 0;
        if (isXLinear) {
            for (var i = 1; i < xLinearGridSize; i++) {
                gridVertexData.push(-1 + i * (2 / xLinearGridSize));
                gridVertexData.push(-1);
                gridVertexData.push(0);
                gridVertexData.push(-1 + i * (2 / xLinearGridSize));
                gridVertexData.push(1);
                gridVertexData.push(0);
                totalLineCount += 1;
            }
        } else {
            for (var i = 0; i < xLogGridSize; i++) {
                var factor = Math.pow(10, i);
                for (var j = 1; j < 10; j++) {
                    gridVertexData.push(-1 + (Math.log10(factor*j)/xLogGridSize)*2);
                    gridVertexData.push(-1);
                    gridVertexData.push(0);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/xLogGridSize)*2);
                    gridVertexData.push(1);
                    gridVertexData.push(0);
                    totalLineCount += 1;
                }
            }
        }

        if (isYLinear) {
            for (var i = 1; i < yLinearGridSize; i++) {
                gridVertexData.push(-1);
                gridVertexData.push(-1 + i * (2 / yLinearGridSize));
                gridVertexData.push(0);
                gridVertexData.push(1);
                gridVertexData.push(-1 + i * (2 / yLinearGridSize));
                gridVertexData.push(0);
                totalLineCount += 1;
            }
        } else {
            for (var i = 0; i < yLogGridSize; i++) {
                var factor = Math.pow(10, i);
                for (var j = 1; j < 10; j++) {
                    gridVertexData.push(-1);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/yLogGridSize)*2);
                    gridVertexData.push(0);
                    gridVertexData.push(1);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/yLogGridSize)*2);
                    gridVertexData.push(0);
                    totalLineCount += 1;
                }
            }
        }
    }

    function normalizeBubbleVal(bubbleVal){
        return Math.sqrt(bubbleScaleSlider.slider("value")*(bubbleVal-minBubbleValue)/(1000*(maxBubbleValue-minBubbleValue)));
    }

    function updateCircleData() {
        currentYearSizes = [];
        currentYearCenterX = [];
        currentYearCenterY = [];
        currentYearRegions = [];

        circleVertexData = [];
        circleIndexData = [];

        var currentYearIndex = yearSlider.slider("value") - baseYear;
        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        var counter = 0;
        for (var i=0; i<countryList.length; i++) {

            var countryName = countryList[i]["name"];
            var bubbleVal = null;
            if (bubbleValues[countryName]) {
                bubbleVal = bubbleValues[countryName][currentYearIndex];
            }
            var gdpPerCapita = gdpPerCapitas[countryName][currentYearIndex];
            var lifeExpectancy = lifeExpectancies[countryName][currentYearIndex];
            if (bubbleVal == null || bubbleVal == 0 || gdpPerCapita == null || gdpPerCapita == 0 || lifeExpectancy == null || lifeExpectancy == 0) {
                continue;
            }
            var normalizedBubbleVal = normalizeBubbleVal(bubbleVal);
            currentYearSizes.push(normalizedBubbleVal);

            var normalizedGdpPerCapita = gdpPerCapitaToScale(gdpPerCapita, isXLinear);
            currentYearCenterX.push(normalizedGdpPerCapita);
            var normalizedLifeExpectancy = lifeExpectancyToScale(lifeExpectancy, isYLinear);
            currentYearCenterY.push(normalizedLifeExpectancy);

            var region = countryList[i]["region"];
            var regionCode = 4;
            if (region == "Asia") {
                regionCode = 1;
            } else if (region === "Europe") {
                regionCode = 2;
            } else if (region == "Africa") {
                regionCode = 3;
            }
            currentYearRegions.push(regionCode);

            circleVertexData.push(0.0);
            circleVertexData.push(0.0);
            circleVertexData.push(counter*1.0);

            for (var j = 0; j < cornerCount; j++) {
                var theta = 2*Math.PI*j/cornerCount;
                var x = Math.cos(theta);
                var y = Math.sin(theta);
                circleVertexData.push(x);
                circleVertexData.push(y);
                circleVertexData.push(counter*1.0);
            }

            var start = counter*(cornerCount+1);
            for(var j = 0; j < cornerCount; j ++) {
                circleIndexData.push(start);
                circleIndexData.push(start + j + 1);
                circleIndexData.push(start + (j + 1) % cornerCount + 1);
            }
            counter++;
            allCircleData.push([countryName, yearSlider.slider("value"), bubbleVal, gdpPerCapita, lifeExpectancy, normalizedBubbleVal, normalizedGdpPerCapita, normalizedLifeExpectancy, regionCode]);
        }
    }

    function updateSelectedCountryCircles() {

        selectedCountrySizes = [];
        selectedCountryCenterX = [];
        selectedCountryCenterY = [];
        selectedCountryRegions = [];
        trendLineVertexData = [];
        trendLineVerticesCounts = [];
        trendLineRegionCodes = [];

        selectedCountryVertexData = [];
        selectedCountryIndexData = [];
        var currentYearIndex = yearSlider.slider("value") - baseYear;
        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        var counter = 0;

        for (var countryIndex = 0; countryIndex < selectedCountries.length; countryIndex++) {
            var countryName = selectedCountries[countryIndex];
            var filteredCountryList = countryList.filter(function(e){ return e["name"] == countryName });
            var region = filteredCountryList[0]["region"];
            var regionCode = 4;
            if (region == "Asia") {
                regionCode = 1;
            } else if (region === "Europe") {
                regionCode = 2;
            } else if (region == "Africa") {
                regionCode = 3;
            }

            var singleTrendLineVertexData = [];
            var singleTrendLineVertexCount = 0;
            var singleTrendLineRegionCode = regionCode;
            for (var k = 0; k <= currentYearIndex; k++) {
                var bubbleVal = null;
                if (bubbleValues[countryName]) {
                    bubbleVal = bubbleValues[countryName][k];
                }
                var gdpPerCapita = gdpPerCapitas[countryName][k];
                var lifeExpectancy = lifeExpectancies[countryName][k];
                if (bubbleVal == null || bubbleVal == 0 || gdpPerCapita == null || gdpPerCapita == 0 || lifeExpectancy == null || lifeExpectancy == 0) {
                    continue;
                }
                var normalizedBubbleVal = normalizeBubbleVal(bubbleVal);
                selectedCountrySizes.push(normalizedBubbleVal);

                var normalizedGdpPerCapita = gdpPerCapitaToScale(gdpPerCapita, isXLinear);
                selectedCountryCenterX.push(normalizedGdpPerCapita);
                var normalizedLifeExpectancy = lifeExpectancyToScale(lifeExpectancy, isYLinear);
                selectedCountryCenterY.push(normalizedLifeExpectancy);
                singleTrendLineVertexData.push(normalizedGdpPerCapita);
                singleTrendLineVertexData.push(normalizedLifeExpectancy);
                singleTrendLineVertexData.push(0);
                singleTrendLineVertexCount += 1;


                selectedCountryRegions.push(regionCode);
                allCircleData.push([countryName, k+baseYear, bubbleVal, gdpPerCapita, lifeExpectancy, normalizedBubbleVal, normalizedGdpPerCapita, normalizedLifeExpectancy, regionCode]);

                selectedCountryVertexData.push(0.0);
                selectedCountryVertexData.push(0.0);
                selectedCountryVertexData.push(counter * 1.0);

                for (var j = 0; j < cornerCount; j++) {
                    var theta = 2 * Math.PI * j / cornerCount;
                    var x = Math.cos(theta);
                    var y = Math.sin(theta);
                    selectedCountryVertexData.push(x);
                    selectedCountryVertexData.push(y);
                    selectedCountryVertexData.push(counter * 1.0);
                }

                var start = counter * (cornerCount + 1);
                for (var j = 0; j < cornerCount; j++) {
                    selectedCountryIndexData.push(start);
                    selectedCountryIndexData.push(start + j + 1);
                    selectedCountryIndexData.push(start + (j + 1) % cornerCount + 1);
                }
                counter += 1;
                if (counter == 200) {
                    counter = 0;
                }
            }
            trendLineVertexData.push(singleTrendLineVertexData);
            trendLineVerticesCounts.push(singleTrendLineVertexCount);
            trendLineRegionCodes.push(singleTrendLineRegionCode);
        }
    }

    function updateHighlightCircleData() {

        highlightVertexData = [];
        highlightIndexData = [];

        highlightVertexData.push(0.0);
        highlightVertexData.push(0.0);
        highlightVertexData.push(0.0);

        for (var j = 0; j < cornerCount; j++) {
            var theta = 2*Math.PI*j/cornerCount;
            var x = Math.cos(theta);
            var y = Math.sin(theta);
            highlightVertexData.push(x);
            highlightVertexData.push(y);
            highlightVertexData.push(0.0);
        }

        var start = 0;
        for(var j = 0; j < cornerCount; j ++) {
            highlightIndexData.push(start);
            highlightIndexData.push(start + j + 1);
            highlightIndexData.push(start + (j + 1) % cornerCount + 1);
        }
    }

    function updateHaloData(centerX, centerY, size, additionalRadius) {
        haloVertexData = [];
        for (var i = 0; i < cornerCount; i++) {
            var theta = 2*Math.PI*i/cornerCount;
            var x = (size + additionalRadius)*Math.cos(theta);
            var y = (size + additionalRadius)*Math.sin(theta);
            haloVertexData.push(centerX + x);
            haloVertexData.push(centerY + y);
            haloVertexData.push(0);
        }
    }

    function updateWebGL() {

        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        updateGridData();

        gl.useProgram(program);

        var isGridLocation = gl.getUniformLocation(program, "useVertexPos");
        gl.uniform1i(isGridLocation, 1);

        var useSolidLocation = gl.getUniformLocation(program, "useSolid");
        gl.uniform1i(useSolidLocation, 1);

        var useHaloColorLocation = gl.getUniformLocation(program, "useHaloColor");
        gl.uniform1i(useHaloColorLocation, 0);

        var useRegionOverrideLocation = gl.getUniformLocation(program, "useRegionOverride");
        gl.uniform1i(useRegionOverrideLocation, 0);

        var gridVertexArray = new Float32Array(gridVertexData);
        var gridVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, gridVertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexBuffer);
        var vertPositionLocation = gl.getAttribLocation(program, "vert_position");
        gl.enableVertexAttribArray(vertPositionLocation);
        gl.vertexAttribPointer(vertPositionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 2*totalLineCount);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.disableVertexAttribArray(vertPositionLocation);

        allCircleData = [];

        updateCircleData();

        var isHighlighted = (highlightSizes.length > 0);
        var isCountrySelected = (selectedCountries.length > 0);

        var currentYearAlpha = Math.min(1.0, 1.5*transparencySlider.slider("value")/100.0);
        if (isHighlighted || isCountrySelected) {
            currentYearAlpha = transparencySlider.slider("value")/100.0;
        }
        drawFilledCircles(gl, currentYearSizes, currentYearCenterX, currentYearCenterY, currentYearRegions, currentYearAlpha, circleVertexData, circleIndexData);

        if (isCountrySelected) {
            var selectedCountryAlpha = 1.0;
            if (isHighlighted) {
                selectedCountryAlpha = transparencySlider.slider("value") / 100.0;
            }
            updateSelectedCountryCircles();
            var sliceSize = 200;
            var currStart = 0;
            var currVertexStart = 0;
            var currIndexStart = 0;
            while ((currStart + sliceSize) < selectedCountrySizes.length) {
                drawFilledCircles(gl, selectedCountrySizes.slice(currStart,currStart+sliceSize), selectedCountryCenterX.slice(currStart,currStart+sliceSize), selectedCountryCenterY.slice(currStart,currStart+sliceSize), selectedCountryRegions.slice(currStart,currStart+sliceSize), selectedCountryAlpha, selectedCountryVertexData.slice(currVertexStart,currVertexStart+sliceSize*99), selectedCountryIndexData.slice(currIndexStart,currIndexStart+sliceSize*96));
                currStart += sliceSize;
                currVertexStart += sliceSize*99;
                currIndexStart += sliceSize*96;
            }
            drawFilledCircles(gl, selectedCountrySizes.slice(currStart,selectedCountrySizes.length), selectedCountryCenterX.slice(currStart,selectedCountryCenterX.length), selectedCountryCenterY.slice(currStart,selectedCountryCenterY.length), selectedCountryRegions.slice(currStart,selectedCountryRegions.length), selectedCountryAlpha, selectedCountryVertexData.slice(currVertexStart,selectedCountryVertexData.length), selectedCountryIndexData.slice(currIndexStart,selectedCountryIndexData.length));
            for (var i = 0; i < trendLineVertexData.length; i++) {
                drawLine(gl, trendLineVertexData[i], trendLineVerticesCounts[i], trendLineRegionCodes[i]);
            }
        }
        if (isHighlighted) {
            updateHighlightCircleData();
            drawFilledCircles(gl, highlightSizes, highlightCenterX, highlightCenterY, highlightRegions, 1.0, highlightVertexData, highlightIndexData);

            updateHaloData(highlightCenterX[0], highlightCenterY[0], highlightSizes[0], 0.05);
            drawCircle(gl, haloVertexData);

            updateHaloData(highlightCenterX[0], highlightCenterY[0], highlightSizes[0], 0.08);
            drawCircle(gl, haloVertexData);

            updateHaloData(highlightCenterX[0], highlightCenterY[0], highlightSizes[0], 0.11);
            drawCircle(gl, haloVertexData);
        }

        gl.useProgram(null);

        window.requestAnimationFrame(updateWebGL);
    }

    function drawFilledCircles(gl, sizes, centerX, centerY, regions, alpha, currentVertexData, currentIndexData) {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        // Set the uniforms
        for (var i = 0; i < sizes.length; i++) {
            var centerUniformName = "centers[" + i + "]";
            var centerLocation = gl.getUniformLocation(program, centerUniformName);
            gl.uniform2f(centerLocation, centerX[i], centerY[i]);
        }
        var sizeLocation = gl.getUniformLocation(program, "sizes[0]");
        gl.uniform1fv(sizeLocation, sizes);

        var regionLocation = gl.getUniformLocation(program, "regions[0]");
        gl.uniform1fv(regionLocation, regions);

        var isGridLocation = gl.getUniformLocation(program, "useVertexPos");
        gl.uniform1i(isGridLocation, 0);

        var useSolidLocation = gl.getUniformLocation(program, "useSolid");
        gl.uniform1i(useSolidLocation, 0);

        var alphaLocation = gl.getUniformLocation(program, "alpha");
        gl.uniform1f(alphaLocation, alpha);

        var useRegionOverrideLocation = gl.getUniformLocation(program, "useRegionOverride");
        gl.uniform1i(useRegionOverrideLocation, 0);

        var currentVertexArray = new Float32Array(currentVertexData);
        var currentVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, currentVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, currentVertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var currentIndexArray = new Uint16Array(currentIndexData);
        var currentIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, currentIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, currentIndexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, currentVertexBuffer);
        var positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 4 * 3, 0);
        var shapeIndexLocation = gl.getAttribLocation(program, "shapeIndex");
        gl.enableVertexAttribArray(shapeIndexLocation);
        gl.vertexAttribPointer(shapeIndexLocation, 1, gl.FLOAT, false, 4 * 3, 4 * 2);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, currentIndexBuffer);
        gl.drawElements(gl.TRIANGLES, sizes.length * cornerCount * 3, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.disableVertexAttribArray(positionLocation);
        gl.disableVertexAttribArray(shapeIndexLocation);
    }

    function drawCircle(gl, vertexData) {

        var isGridForFragmentShaderLocation = gl.getUniformLocation(program, "useVertexPos");
        gl.uniform1i(isGridForFragmentShaderLocation, 1);

        var useSolidLocation = gl.getUniformLocation(program, "useSolid");
        gl.uniform1i(useSolidLocation, 1);

        var useHaloColorLocation = gl.getUniformLocation(program, "useHaloColor");
        gl.uniform1i(useHaloColorLocation, 1);

        var useRegionOverrideLocation = gl.getUniformLocation(program, "useRegionOverride");
        gl.uniform1i(useRegionOverrideLocation, 0);

        var vertexArray = new Float32Array(vertexData);
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        var vertPositionLocation = gl.getAttribLocation(program, "vert_position");
        gl.enableVertexAttribArray(vertPositionLocation);
        gl.vertexAttribPointer(vertPositionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINE_LOOP, 0, cornerCount);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.disableVertexAttribArray(vertPositionLocation);
    }

    function drawLine(gl, vertexData, totalVerticesCount, regionCode) {

        var isGridForFragmentShaderLocation = gl.getUniformLocation(program, "useVertexPos");
        gl.uniform1i(isGridForFragmentShaderLocation, 1);

        var useSolidLocation = gl.getUniformLocation(program, "useSolid");
        gl.uniform1i(useSolidLocation, 0);

        var useHaloColorLocation = gl.getUniformLocation(program, "useHaloColor");
        gl.uniform1i(useHaloColorLocation, 0);

        var useRegionOverrideLocation = gl.getUniformLocation(program, "useRegionOverride");
        gl.uniform1i(useRegionOverrideLocation, 1);

        var regionOverrideLocation = gl.getUniformLocation(program, "regionOverride");
        gl.uniform1f(regionOverrideLocation, regionCode);

        var vertexArray = new Float32Array(vertexData);
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        var vertPositionLocation = gl.getAttribLocation(program, "vert_position");
        gl.enableVertexAttribArray(vertPositionLocation);
        gl.vertexAttribPointer(vertPositionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINE_STRIP, 0, totalVerticesCount);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.disableVertexAttribArray(vertPositionLocation);
    }

    window.requestAnimationFrame(updateWebGL);

    function updateCursorData(event) {
        $("#cursor-tooltip").tooltip('hide');
        highlightSizes = [];
        highlightCenterX = [];
        highlightCenterY = [];
        highlightRegions = [];
        $("#gdpPerCapita").text("");
        $("#lifeExpectancy").text("");
        $("#country").text("");
        $("#year").text("");
        $("#bubble").text("");
        $("#gdpPerCapitaDataPoint").text("");
        $("#lifeExpectancyDataPoint").text("");

        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        var clientRect = $("#webglCanvas")[0].getBoundingClientRect();
        var xPos = event.clientX - clientRect.left;
        var normalizedXPos = xPos/(clientRect.right - clientRect.left);
        var gdpPerCapitaForDisplay = fromScaleToGdpPerCapita(normalizedXPos, isXLinear).toFixed(2);
        $("#gdpPerCapita").text(gdpPerCapitaForDisplay);

        var yPos = clientRect.bottom - event.clientY;
        var normalizedYPos = yPos/(clientRect.bottom - clientRect.top);
        var lifeExpectancyForDisplay = fromScaleToLifeExpectancy(normalizedYPos, isYLinear).toFixed(2);
        $("#lifeExpectancy").text(lifeExpectancyForDisplay);
        $("#cursor-tooltip").css({top: window.pageYOffset + event.pageY, left: window.pageXOffset + event.pageX });
        $("#cursor-tooltip").attr("title", "<h6>GDP per Capita: " + gdpPerCapitaForDisplay + "</h6>" +
                "<h6>Life Expectancy: " + lifeExpectancyForDisplay + "</h6>");

        for (var i = allCircleData.length-1; i >= 0; i--) {
            var entry = allCircleData[i];
            var normalizedBubbleVal = entry[entry.length-4];
            var normalizedGdpPerCapita = entry[entry.length-3];
            var normalizedLifeExpectancy = entry[entry.length-2];
            var regionCode = entry[entry.length-1];

            var glNormalizedXPos = normalizedXPos*2-1;
            var glNormalizedYPos = normalizedYPos*2-1;
            if (Math.sqrt(Math.pow(glNormalizedXPos-normalizedGdpPerCapita, 2) + Math.pow(glNormalizedYPos-normalizedLifeExpectancy,2)) <= normalizedBubbleVal) {
                highlightSizes.push(normalizedBubbleVal);
                highlightCenterX.push(normalizedGdpPerCapita);
                highlightCenterY.push(normalizedLifeExpectancy);
                highlightRegions.push(regionCode);
                $("#country").text(entry[0]);
                $("#year").text(entry[1]);
                if ($("#datasetSelection").val() == "Population") {
                    $("#currentBubbleVal").text(parseInt(entry[2].toFixed(0)).toLocaleString());
                } else {
                    $("#currentBubbleVal").text(entry[2].toFixed(2));
                }
                $("#gdpPerCapitaDataPoint").text(entry[3].toFixed(2));
                $("#lifeExpectancyDataPoint").text(entry[4].toFixed(2));
                $("#cursor-tooltip").attr("title", "<h6>Country: " + entry[0] + "</h6>" +
                        "<h6>Year: " + entry[1] + "</h6>" +
                        "<h6>" + $("#datasetSelection").val() + ": " + parseInt(entry[2].toFixed(0)).toLocaleString() + "</h6>" +
                        "<h6>GDP per Capital: " + entry[3].toFixed(2) + "</h6>" +
                        "<h6>Life Expectancy: " + entry[4].toFixed(2) + "</h6>");
                break;
            }
        }
        $("#cursor-tooltip").tooltip("fixTitle");
        $("#cursor-tooltip").tooltip('show');

    }

    function updateCountrySelection(event) {
        var clientRect = $("#webglCanvas")[0].getBoundingClientRect();
        var xPos = event.clientX - clientRect.left;
        var normalizedXPos = xPos/(clientRect.right - clientRect.left);

        var yPos = clientRect.bottom - event.clientY;
        var normalizedYPos = yPos/(clientRect.bottom - clientRect.top);

        for (var i = allCircleData.length-1; i >= 0; i--) {
            var entry = allCircleData[i];
            var normalizedBubbleVal = entry[entry.length-4];
            var normalizedGdpPerCapita = entry[entry.length-3];
            var normalizedLifeExpectancy = entry[entry.length-2];

            var glNormalizedXPos = normalizedXPos*2-1;
            var glNormalizedYPos = normalizedYPos*2-1;
            if (Math.sqrt(Math.pow(glNormalizedXPos-normalizedGdpPerCapita, 2) + Math.pow(glNormalizedYPos-normalizedLifeExpectancy,2)) <= normalizedBubbleVal) {
                if ($.inArray(entry[0], selectedCountries) == -1) {
                    addCountryByName(entry[0]);
                } else {
                    removeCountryByName(entry[0]);
                }
                break;
            }
        }
    }

    $("#webglCanvas").mousemove(function (event) {
        updateCursorData(event);
    });

    $("#webglCanvas").mouseover(function (event) {
        updateCursorData(event);
    });

    $("#webglCanvas").mouseout(function (event) {
        $("#gdpPerCapita").text("");
        $("#lifeExpectancy").text("");
        $("#country").text("");
        $("#year").text("");
        $("#currentBubbleVal").text("");
        $("#gdpPerCapitaDataPoint").text("");
        $("#lifeExpectancyDataPoint").text("");
        $("#cursor-tooltip").tooltip('hide');
    });

    $("#webglCanvas").click(function (event) {
        updateCountrySelection(event);
    });

</script>
</body>
</html>