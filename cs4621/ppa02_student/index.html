<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: PPA2 -- Data Visualization</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<>
<div class="container">
    <h1>CS 4621 PPA2 <span class="subtitle">Data Visualization</span></h1>

    <h2>Team Members</h2>

    <ul>
        <li>Please list your team members with NetID in this unordered list.</li>
        <li>Siyuan Wang(sw884)</li>
    </ul>

    <div style="float:left; width: 60%">
        <div align="center" id="currentYear"></div>
        <div align="center">
            <canvas id="webglCanvas" style="border: none; background-color: lavenderblush;" width="512" height="512"></canvas>
        </div>
        <div>
            <table>
                <tr>
                    <td>
                        <button id="playButton">Play!</button>
                    </td>
                    <td width="10"></td>
                    <td>
                        <table>
                            <tr>
                                <td width="720" id="yearSlider"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
            <table class="table">
                <tr>
                    <td width="200">
                        <div>GDP per Capita Scale</div>
                    </td>
                    <td>
                        <select id="gdpPerCapitaScale">
                            <option value="Logarithm" selected="selected">Logarithm</option>
                            <option value="Linear">Linear</option>
                        </select>
                    </td>
                    <td width="250">
                        <div>Life Expectancy Scale</div>
                    </td>
                    <td>
                        <select id="lifeExpectancyScale">
                            <option value="Logarithm">Logarithm</option>
                            <option value="Linear" selected="selected">Linear</option>
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>
                        <div>Population Scale</div>
                    </td>
                    <td>
                        <table>
                            <tr>
                                <td width="360" id="populationScaleSlider"></td>
                            </tr>
                        </table>
                    </td>
                    <td>
                        <div>Transparency</div>
                    </td>
                    <td>
                        <table>
                            <tr>
                                <td width="360" id="transparencySlider"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </div>
    </div>
    <div style="float:right; width: 39%">
        <div>Cursor</div>
            <table border="1">
                <tr>
                    <td>GDP per Capita($)</td>
                    <td id="gdpPerCapita" width="50%" ></td>
                </tr>
                <tr>
                    <td>Life Expectancy(years)</td>
                    <td id="lifeExpectancy" width="50%"></td>
                </tr>
            </table>
        <div>Data Point</div>
            <table border="1">
                <tr>
                    <td>Country</td>
                    <td id="country" width="50%"></td>
                </tr>
                <tr>
                    <td>Year</td>
                    <td id="year" width="50%"></td>
                </tr>
                <tr>
                    <td>Population</td>
                    <td id="population" width="50%"></td>
                </tr>
                <tr>
                    <td>GDP per Capita($)</td>
                    <td id="gdpPerCapitaDataPoint" width="50%"></td>
                </tr>
                <tr>
                    <td>Life Expectancy(years)</td>
                    <td id="lifeExpectancyDataPoint" width="50%"></td>
                </tr>
            </table>
        <div>Country List</div>
        <table>
            <tr>
                <td width="300">
                    <div style="overflow: auto; height: 320px;" id="countryCheckBoxes"></div>
                </td>
                <td width="10"></td>
                <td width="300">
                    <div style="overflow: auto; height: 320px" id="countryList"></div>
                </td>
            </tr>
        </table><br>
        <button id="selectAllButton">Select All</button> &nbsp;
        <button id="deselectAllButton">Deselect All</button>
    </div>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<!-- Data -->
<script src="data/country_list.js"></script>
<script src="data/population.js"></script>
<script src="data/gdp_per_capita.js"></script>
<script src="data/life_expectancy.js"></script>
<script>
    var populationScaleSlider = $("#populationScaleSlider");
    var transparencySlider = $("#transparencySlider");

    populationScaleSlider.slider({
        min:1,
        max:100
    });
    transparencySlider.slider({
        min:1,
        max:100
    });
</script>

<script>
    // Year slider and the play button.
    var yearSlider = $("#yearSlider");
    var playButton = $("#playButton");

    yearSlider.slider({
        min: 1800,
        max: 2015
    });

    var isPlaying = false;
    var lastYearUpdate;
    var yearUpdateInterval = 100.0;

    function startPlay() {
        isPlaying = true;
        lastYearUpdate = performance.now();
        yearSlider.slider("disable");
        playButton.text("Stop!");
    }

    function stopPlay() {
        playButton.text("Play!");
        isPlaying = false;
        yearSlider.slider("enable");
    }

    playButton.click(function () {
        if (isPlaying) {
            stopPlay();
        } else {
            startPlay();
        }
    });

    function updateUi() {
        var year = yearSlider.slider("value");

        if (isPlaying) {
            if (year == 2015) {
                stopPlay();
            } else {
                var currentTime = performance.now();
                if (currentTime - lastYearUpdate > yearUpdateInterval) {
                    lastYearUpdate = currentTime;
                    yearSlider.slider("value", year + 1);
                }
            }
        }

        year = yearSlider.slider("value");
        $("#currentYear").html("<h1>" + year + "</h1>");

//        updateCircleData();
        window.requestAnimationFrame(updateUi);
    }
    window.requestAnimationFrame(updateUi);

    // Checkbox lists.
    var countries = getCountryList();

    var selectedCountries = [];

    function updatecountryList() {
        $("#countryList").html(
                "<ul>" +
                selectedCountries.map(function(name) {
                    return "<li>" + name + "</li>";
                }).join("") +
                "</ul>"
        );
    }

    function createCountryCheckBoxes() {
        var countryHtmls = [];
        var i;
        for(i=0;i<countries.length;i++) {
            var name = countries[i].name;
            countryHtmls.push("<input type='checkbox' value='" + name + "' id='checkBox" + i + "'> " + name + "<br>");
        }
        $("#countryCheckBoxes").html(countryHtmls.join(""));

        function setCheckBoxChangeFunction(i) {
            var checkBoxName = "checkBox" + i;
            var checkBox = $("#" + checkBoxName);
            var name = countries[i].name;
            checkBox.change(function() {
                var checked = checkBox.prop("checked");
                if (!checked) {
                    var index = selectedCountries.indexOf(name);
                    if (index > -1) {
                        selectedCountries.splice(index,1);
                    }
                } else {
                    selectedCountries.push(name);
                }
                updatecountryList();
            });
        }

        for(i=0;i<countries.length;i++) {
            setCheckBoxChangeFunction(i);
        }
    }
    createCountryCheckBoxes();

    function addCountry(country) {
        var name = country.name;
        var index = countries.indexOf(country);
        if (index > -1) {
            var checkBoxName = "checkBox" + index;
            var checkBox = $("#" + checkBoxName);
            if (!checkBox.prop("checked")) {
                checkBox.prop("checked", true);
                selectedCountries.push(name);
            }
        }
    }

    function removeCountry(name) {
        var index = countries.indexOf(name);
        if (index > -1) {
            var checkBoxName = "checkBox" + index;
            var checkBox = $("#" + checkBoxName);
            if (checkBox.prop("checked")) {
                selectedCountries.splice(name, 1);
                checkBox.prop("checked", false);
            }
        }
    }

    $("#selectAllButton").click(function() {
        countries.forEach(addCountry);
        updatecountryList();
    });

    $("#deselectAllButton").click(function() {
        countries.forEach(removeCountry);
        updatecountryList();
    });
</script>
<script id="vertexShader" type="x-shader/x-vertex">
    #define SHAPE_COUNT 195

    uniform vec2 centers[SHAPE_COUNT];
    uniform float sizes[SHAPE_COUNT];
    uniform float regions[SHAPE_COUNT];
    uniform int isGrid;

    attribute vec2 position;
    attribute float shapeIndex;
    attribute vec3 vert_position;

    varying float region;


    void main() {
        if (isGrid == 1) {
            gl_Position = vec4(vert_position, 1.0);
        } else {
            vec2 center = centers[int(shapeIndex)];
            float size = sizes[int(shapeIndex)];
            vec2 p = size*position + center;
            gl_Position = vec4(p, 0.0, 1.0);
            region = regions[int(shapeIndex)];
        }
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    #define SHAPE_COUNT 195
    precision highp float;

    varying float region;
    uniform int isGridForFragmentShader;
    uniform float alpha;

    void main() {
        if (isGridForFragmentShader == 1) {
            gl_FragColor = vec4(0.0,0.0,0.0, 1.0);
        } else {
            if (int(region) == 1) {
                gl_FragColor = vec4(1.0,0.0,0.0, alpha);
            } else if (int(region) == 2) {
                gl_FragColor = vec4(0.0,1.0,0.0, alpha);
            } else if (int(region) == 3) {
                gl_FragColor = vec4(0.0,0.0,1.0, alpha);
            } else {
                gl_FragColor = vec4(1.0,1.0,0.0, alpha);
            }
        }
    }
</script>
<script>
    function initializeWebGL(canvasName) {
        var canvas = $("#" + canvasName);
        // Getting WebGL context the right way
        var gl = null;
        try {
            gl = canvas[0].getContext("experimental-webgl");
            if (!gl) {
                gl = canvas[0].getContext("webgl");
            }
        } catch (error) {
            // NO-OP
        }
        if (!gl) {
            alert("Could not get WebGL context!");
            throw new Error("Could not get WebGL context!");
        }
        return gl;
    }

    function createShader(gl, shaderScriptId) {
        var shaderScript = $("#" + shaderScriptId);
        var shaderSource = shaderScript[0].text;
        var shaderType = null;
        if (shaderScript[0].type == "x-shader/x-vertex") {
            shaderType = gl.VERTEX_SHADER;
        } else if (shaderScript[0].type == "x-shader/x-fragment") {
            shaderType = gl.FRAGMENT_SHADER;
        } else {
            throw new Error("Invalid shader type: " + shaderScript[0].type)
        }
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            var infoLog = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error("An error occurred compiling the shader: " + infoLog);
        } else {
            return shader;
        }
    }

    function createGlslProgram(gl, vertexShaderId, fragmentShaderId) {
        var program = gl.createProgram();
        gl.attachShader(program, createShader(gl, vertexShaderId));
        gl.attachShader(program, createShader(gl, fragmentShaderId));
        gl.linkProgram(program);
        gl.validateProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            var infoLog = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error("An error occurred linking the program: " + infoLog);
        } else {
            return program;
        }
    }

    var gl = initializeWebGL("webglCanvas");
    var program = createGlslProgram(gl, "vertexShader", "fragmentShader");

    var xLinearGridSize = 6;
    var yLinearGridSize = 5;
    var xLogGridSize = 3;
    var yLogGridSize = 2;
    var totalLineCount = 0;
    var cornerCount = 32;
    var circleVertexData = [];
    var circleIndexData = [];
    var gridVertexData = [];
    var highlightVertexData = [];
    var highlightIndexData = [];

    var currentYearSizes = [];
    var currentYearCenterX = [];
    var currentYearCenterY = [];
    var currentYearRegions = [];
    var allCircleData = [];

    var highlightSizes = [];
    var highlightCenterX = [];
    var highlightCenterY = [];
    var highlightRegions = [];

    var gdpPerCapitas = getGdpPerCapita();
    var lifeExpectancies = getLifeExpectancy();
    var populations = getPopulation();
    var countryList = getCountryList();
    var shapeCount = countryList.length;
    var populationScaleSlider = $("#populationScaleSlider");
    var transparencySlider = $("#transparencySlider");
    populationScaleSlider.slider("value", 40);
    transparencySlider.slider("value", 70);

    function flattenValue(someMap) {
        var keys = Object.keys(someMap);
        var arrayOfValueArray = keys.map(function(t) { return someMap[t];});
        var falttenedArr = [].concat.apply([], arrayOfValueArray);
        return falttenedArr.filter(function(someVal){ return someVal != null });
    }
    var minGDP = Math.min.apply(Math, flattenValue(gdpPerCapitas));
    var maxGDP = Math.max.apply(Math, flattenValue(gdpPerCapitas));
    var minLifeExpectancy = Math.min.apply(Math, flattenValue(lifeExpectancies));
    var maxLifeExpectancy = Math.max.apply(Math, flattenValue(lifeExpectancies));
    var minPopulation = Math.min.apply(Math, flattenValue(populations));
    var maxPopulation = Math.max.apply(Math, flattenValue(populations));

    var prevYearSliderValue = -1.0;

    function updateCircleData() {
        currentYearSizes = [];
        currentYearCenterX = [];
        currentYearCenterY = [];
        currentYearRegions = [];

        allCircleData = [];

        circleVertexData = [];
        circleIndexData = [];

        for (var i = 0; i < shapeCount; i++) {
            circleVertexData.push(0.0);
            circleVertexData.push(0.0);
            circleVertexData.push(i*1.0);

            for (var j = 0; j < cornerCount; j++) {
                var theta = 2*Math.PI*j/cornerCount;
                var x = Math.cos(theta);
                var y = Math.sin(theta);
                circleVertexData.push(x);
                circleVertexData.push(y);
                circleVertexData.push(i*1.0);
            }
        }

        for (var i = 0; i < shapeCount; i++) {
            var start = i*(cornerCount+1);
            for(var j = 0; j < cornerCount; j ++) {
                circleIndexData.push(start);
                circleIndexData.push(start + j + 1);
                circleIndexData.push(start + (j + 1) % cornerCount + 1);
            }
        }

        var currentYearIndex = yearSlider.slider("value") - 1800;
        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        for (var i=0; i<shapeCount; i++) {

            var countryName = countryList[i]["name"];
            var populationVal = populations[countryName][currentYearIndex];
            var gdpPerCapita = gdpPerCapitas[countryName][currentYearIndex];
            var lifeExpectancy = lifeExpectancies[countryName][currentYearIndex];
            if (populationVal == null || populationVal == 0 || gdpPerCapita == null || gdpPerCapita == 0 || lifeExpectancy == null || lifeExpectancy == 0) {
                continue;
            }
            var normalizedPopulationval = Math.sqrt(populationScaleSlider.slider("value")*(populationVal-minPopulation)/(1000*(maxPopulation-minPopulation)));
            currentYearSizes.push(normalizedPopulationval);

            var normalizedGdpPerCapita = gdpPerCapitaToScale(gdpPerCapita, isXLinear);
            currentYearCenterX.push(normalizedGdpPerCapita);
            var normalizedLifeExpectancy = lifeExpectancyToScale(lifeExpectancy, isYLinear);
            currentYearCenterY.push(normalizedLifeExpectancy);

            var region = countryList[i]["region"];
            var regionCode = 4;
            if (region == "Asia") {
                regionCode = 1;
            } else if (region === "Europe") {
                regionCode = 2;
            } else if (region == "Africa") {
                regionCode = 3;
            }
            currentYearRegions.push(regionCode);
            allCircleData.push([countryName, yearSlider.slider("value"), populationVal, gdpPerCapita, lifeExpectancy, normalizedPopulationval, normalizedGdpPerCapita, normalizedLifeExpectancy, regionCode]);
        }
        prevYearSliderValue = yearSlider.slider("value");
    }

    function updateHighlightCircleData() {

        highlightVertexData = [];
        highlightIndexData = [];

        highlightVertexData.push(0.0);
        highlightVertexData.push(0.0);
        highlightVertexData.push(0.0);

        for (var j = 0; j < cornerCount; j++) {
            var theta = 2*Math.PI*j/cornerCount;
            var x = Math.cos(theta);
            var y = Math.sin(theta);
            highlightVertexData.push(x);
            highlightVertexData.push(y);
            highlightVertexData.push(0.0);
        }

        var start = 0;
        for(var j = 0; j < cornerCount; j ++) {
            highlightIndexData.push(start);
            highlightIndexData.push(start + j + 1);
            highlightIndexData.push(start + (j + 1) % cornerCount + 1);
        }
    }

    function gdpPerCapitaToScale(gdpPerCapita, isLinear){
        if (isLinear) {
            return ((gdpPerCapita-minGDP)/(maxGDP-minGDP))*2-1;
        } else {
            return ((Math.log10(gdpPerCapita) - Math.floor(Math.log10(minGDP)))/xLogGridSize)*2-1;
        }
    }

    function fromScaleToGdpPerCapita(xVal, isLinear) {
        if (isLinear) {
            return xVal*(maxGDP-minGDP) + minGDP;
        } else {
            return Math.pow(10, xVal*xLogGridSize + Math.floor(Math.log10(minGDP)));
        }
    }

    function lifeExpectancyToScale(lifeExpectancy, isLinear){
        if (isLinear) {
            return ((lifeExpectancy-minLifeExpectancy)/(maxLifeExpectancy-minLifeExpectancy))*2-1;
        } else {
            return (Math.log10(lifeExpectancy)/yLogGridSize)*2-1;
        }
    }

    function fromScaleToLifeExpectancy(yVal, isLinear) {
        if (isLinear) {
            return yVal*(maxLifeExpectancy-minLifeExpectancy) + minLifeExpectancy;
        } else {
            return Math.pow(10, yVal*yLogGridSize);
        }
    }

    function updateGridData() {
        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        gridVertexData = [];
        totalLineCount = 0;
        if (isXLinear) {
            for (var i = 1; i < xLinearGridSize; i++) {
                gridVertexData.push(-1 + i * (2 / xLinearGridSize));
                gridVertexData.push(-1);
                gridVertexData.push(0);
                gridVertexData.push(-1 + i * (2 / xLinearGridSize));
                gridVertexData.push(1);
                gridVertexData.push(0);
                totalLineCount += 1;
            }
        } else {
            for (var i = 0; i < xLogGridSize; i++) {
                var factor = Math.pow(10, i);
                for (var j = 1; j < 10; j++) {
                    gridVertexData.push(-1 + (Math.log10(factor*j)/xLogGridSize)*2);
                    gridVertexData.push(-1);
                    gridVertexData.push(0);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/xLogGridSize)*2);
                    gridVertexData.push(1);
                    gridVertexData.push(0);
                    totalLineCount += 1;
                }
            }
        }

        if (isYLinear) {
            for (var i = 1; i < yLinearGridSize; i++) {
                gridVertexData.push(-1);
                gridVertexData.push(-1 + i * (2 / yLinearGridSize));
                gridVertexData.push(0);
                gridVertexData.push(1);
                gridVertexData.push(-1 + i * (2 / yLinearGridSize));
                gridVertexData.push(0);
                totalLineCount += 1;
            }
        } else {
            for (var i = 0; i < yLogGridSize; i++) {
                var factor = Math.pow(10, i);
                for (var j = 1; j < 10; j++) {
                    gridVertexData.push(-1);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/yLogGridSize)*2);
                    gridVertexData.push(0);
                    gridVertexData.push(1);
                    gridVertexData.push(-1 + (Math.log10(factor*j)/yLogGridSize)*2);
                    gridVertexData.push(0);
                    totalLineCount += 1;
                }
            }
        }
    }

    function updateWebGL() {

        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        updateGridData();

        gl.useProgram(program);

        var isGridLocation = gl.getUniformLocation(program, "isGrid");
        gl.uniform1i(isGridLocation, 1);

        var isGridLocation = gl.getUniformLocation(program, "isGridForFragmentShader");
        gl.uniform1i(isGridLocation, 1);

        var gridVertexArray = new Float32Array(gridVertexData);
        var gridVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, gridVertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexBuffer);
        var vertPositionLocation = gl.getAttribLocation(program, "vert_position");
        gl.enableVertexAttribArray(vertPositionLocation);
        gl.vertexAttribPointer(vertPositionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 2*totalLineCount);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.disableVertexAttribArray(vertPositionLocation);

        updateCircleData();

        if (highlightSizes.length > 0) {
            var transparencyFromSlider = transparencySlider.slider("value")/200.0;
            drawCircles(gl, currentYearSizes, currentYearCenterX, currentYearCenterY, currentYearRegions, transparencyFromSlider, circleVertexData, circleIndexData);

            updateHighlightCircleData();
            drawCircles(gl, highlightSizes, highlightCenterX, highlightCenterY, highlightRegions, 1.0, highlightVertexData, highlightIndexData);
        } else {
            var transparencyFromSlider = Math.min(1.0, 2*transparencySlider.slider("value")/100.0);
            drawCircles(gl, currentYearSizes, currentYearCenterX, currentYearCenterY, currentYearRegions, transparencyFromSlider, circleVertexData, circleIndexData);

        }

        gl.useProgram(null);

        window.requestAnimationFrame(updateWebGL);
    }

    function drawCircles(gl, sizes, centerX, centerY, regions, alpha, currentVertexData, currentIndexData) {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        // Set the uniforms
        for (var i = 0; i < sizes.length; i++) {
            var centerUniformName = "centers[" + i + "]";
            var centerLocation = gl.getUniformLocation(program, centerUniformName);
            gl.uniform2f(centerLocation, centerX[i], centerY[i]);
        }
        var sizeLocation = gl.getUniformLocation(program, "sizes[0]");
        gl.uniform1fv(sizeLocation, sizes);

        var regionLocation = gl.getUniformLocation(program, "regions[0]");
        gl.uniform1fv(regionLocation, regions);

        var isGridLocation = gl.getUniformLocation(program, "isGrid");
        gl.uniform1i(isGridLocation, 0);

        var isGridLocation = gl.getUniformLocation(program, "isGridForFragmentShader");
        gl.uniform1i(isGridLocation, 0);

        var alphaLocation = gl.getUniformLocation(program, "alpha");
        gl.uniform1f(alphaLocation, alpha);

        var currentVertexArray = new Float32Array(currentVertexData);
        var currentVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, currentVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, currentVertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var currentIndexArray = new Uint16Array(currentIndexData);
        var currentIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, currentIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, currentIndexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, currentVertexBuffer);
        var positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 4 * 3, 0);
        var shapeIndexLocation = gl.getAttribLocation(program, "shapeIndex");
        gl.enableVertexAttribArray(shapeIndexLocation);
        gl.vertexAttribPointer(shapeIndexLocation, 1, gl.FLOAT, false, 4 * 3, 4 * 2);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, currentIndexBuffer);
        gl.drawElements(gl.TRIANGLES, sizes.length * cornerCount * 3, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.disableVertexAttribArray(positionLocation);
        gl.disableVertexAttribArray(shapeIndexLocation);
    }

    window.requestAnimationFrame(updateWebGL);

    function updateCursorData(event) {
        highlightSizes = [];
        highlightCenterX = [];
        highlightCenterY = [];
        highlightRegions = [];

        var isXLinear = $("#gdpPerCapitaScale").val() === "Linear";
        var isYLinear = $("#lifeExpectancyScale").val() === "Linear";
        var clientRect = $("#webglCanvas")[0].getBoundingClientRect();
        var xPos = event.clientX - clientRect.left;
        var normalizedXPos = xPos/(clientRect.right - clientRect.left);
        $("#gdpPerCapita").text(fromScaleToGdpPerCapita(normalizedXPos, isXLinear).toFixed(2));

        var yPos = clientRect.bottom - event.clientY;
        var normalizedYPos = yPos/(clientRect.bottom - clientRect.top);
        $("#lifeExpectancy").text(fromScaleToLifeExpectancy(normalizedYPos, isYLinear).toFixed(2));

        for (var i = allCircleData.length-1; i >= 0; i--) {
//            allCircleData.push([countryName, yearSlider.slider("value"), populationVal, gdpPerCapita, lifeExpectancy, normalizedPopulationval, normalizedGdpPerCapita, normalizedLifeExpectancy], regionCode);
            var entry = allCircleData[i];
            var normalizedPopulationval = entry[entry.length-4];
            var normalizedGdpPerCapita = entry[entry.length-3];
            var normalizedLifeExpectancy = entry[entry.length-2];
            var regionCode = entry[entry.length-1];

            var glNormalizedXPos = normalizedXPos*2-1;
            var glNormalizedYPos = normalizedYPos*2-1;
            if (Math.sqrt(Math.pow(glNormalizedXPos-normalizedGdpPerCapita, 2) + Math.pow(glNormalizedYPos-normalizedLifeExpectancy,2)) <= normalizedPopulationval) {
                highlightSizes.push(normalizedPopulationval);
                highlightCenterX.push(normalizedGdpPerCapita);
                highlightCenterY.push(normalizedLifeExpectancy);
                highlightRegions.push(regionCode);
                break;
            }
        }
    }

    $("#webglCanvas").mousemove(function(event){
        updateCursorData(event);
    });

    $("#webglCanvas").mouseover(function(event){
        updateCursorData(event);
    });

    $("#webglCanvas").mouseout(function(event){
        $("#gdpPerCapita").text("");
        $("#lifeExpectancy").text("");
    });

</script>
</body>
</html>