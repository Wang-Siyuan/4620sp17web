<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: PPA1 -- WebGL Ray</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container">
    <h1>CS 4621 PPA1 <span class="subtitle">WebGL Ray</span></h1>

    <div align="center">
        <canvas id="webglCanvas" style="border: none; background-color: black;" width="512" height="512"></canvas>
    </div>

    <br>

    <table class="table table-bordered">
        <tr>
            <td align="right">Render Mode:</td>
            <td>
                <select id="renderMode">
                    <option value="FACE_COLOR">Face Color</option>
                    <option value="NORMAL">Normal</option>
                    <option value="SHADOW">Shadow</option>
                    <option value="FULL">Full Shading</option>
                </select>
            </td>
            <td align="right">Scene:</td>
            <td>
                <select id="scene">
                    <option value="triangle">Triangle Scene</option>
                    <option value="cube">Cube Scene</option>
                    <option value="full">Full Scene</option>
                </select>
            </td>
        </tr>
        <tr>
            <td colspan="4" align="center"><b>Camera Settings</b></td>
        </tr>
        <tr>
            <td align="right">Camera Eye:</td>
            <td>
                X = <input type="text" id="cameraEyeX" value="1.0">
            </td>
            <td>
                Y = <input type="text" id="cameraEyeY" value="1.0">
            </td>
            <td>
                Z = <input type="text" id="cameraEyeZ" value="1.0">
            </td>
        </tr>
        <tr>
            <td align="right">Camera Target:</td>
            <td>
                X = <input type="text" id="cameraTargetX" value="0.0">
            </td>
            <td>
                Y = <input type="text" id="cameraTargetY" value="0.0">
            </td>
            <td>
                Z = <input type="text" id="cameraTargetZ" value="0.0">
            </td>
        </tr>
        <tr>
            <td align="right">Camera Up:</td>
            <td>
                X = <input type="text" id="cameraUpX" value="0.0">
            </td>
            <td>
                Y = <input type="text" id="cameraUpY" value="1.0">
            </td>
            <td>
                Z = <input type="text" id="cameraUpZ" value="0.0">
            </td>
        </tr>
        <tr>
            <td align="right">Camera Field of View:</td>
            <td colspan="3">
                <input type="text" id="cameraFov" value="30.0">
            </td>
        </tr>
        <tr>
            <td colspan="4" align="center"><b>Light Settings</b></td>
        </tr>
        <tr>
            <td align="right">Light Position:</td>
            <td>
                X = <input type="text" id="lightPositionX" value="1.0">
            </td>
            <td>
                Y = <input type="text" id="lightPositionY" value="1.0">
            </td>
            <td>
                Z = <input type="text" id="lightPositionZ" value="1.0">
            </td>
        </tr>
        <tr>
            <td align="right">Light Intensity:</td>
            <td>
                R = <input type="text" id="lightIntensityR" value="1.0">
            </td>
            <td>
                G = <input type="text" id="lightIntensityG" value="1.0">
            </td>
            <td>
                B = <input type="text" id="lightIntensityB" value="1.0">
            </td>
        </tr>
        <tr>
            <td colspan="4" align="center"><b>Background Settings</b></td>
        </tr>
        <tr>
            <td align="right">Background Color:</td>
            <td>
                R = <input type="text" id="backgroundColorR" value="0.0">
            </td>
            <td>
                G = <input type="text" id="backgroundColorG" value="0.0">
            </td>
            <td>
                B = <input type="text" id="backgroundColorB" value="0.0">
            </td>
        </tr>
    </table>

    <h2>Team Members</h2>

    <ul>
        <li>Please list your team members with NetID in this unordered list.</li>
        <li>Example: Steve Marschner (srm2)</li>
    </ul>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="scenes.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    varying vec3 geom_coord;

    void main() {
        gl_Position = vec4(vert_position, 1.0);
        geom_coord = vert_position;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    #define MAX_TRIANGLES 132
    precision highp float;

    uniform int renderMode;
    uniform vec3 vertexPositions[MAX_TRIANGLES*3];
    uniform vec3 triangleColors[MAX_TRIANGLES];
    uniform int numOfTriangles;

    uniform vec3 cameraEye;
    uniform vec3 cameraTarget;
    uniform vec3 cameraUp;
    uniform float cameraFov;
    uniform vec3 color;

    varying vec3 geom_coord;

    vec3 getNormal(vec3 v0, vec3 v1, vec3 v2) {
        vec3 e1 = vec3(v1.xyz);
        e1 = e1 - v0;
        vec3 e2 = vec3(v2.xyz);
        e2 = v2 - v0;
        return normalize(cross(e1,e2));
    }

    void main() {
        gl_FragColor = vec4(color, 1.0);
        vec3 basis_z = normalize(cameraEye - cameraTarget);
        vec3 basis_x = normalize(cross(cameraUp, basis_z));
        vec3 basis_y = normalize(cross(basis_z,basis_x));
        float s = tan(radians(cameraFov/2.0));
        vec3 rayDir = normalize(basis_z*(-1.0) + basis_x*(s*geom_coord.x) + basis_y*(s*geom_coord.y));
        float rayEnd = 1.0/0.0;

        for(int index=0; index<MAX_TRIANGLES; index++) {
            if (index >= numOfTriangles)
                break;

            vec3 v0 = vertexPositions[3*index];
            vec3 v1 = vertexPositions[3*index+1];
            vec3 v2 = vertexPositions[3*index+2];

            if (renderMode == 1) {
                float a = v0.x-v1.x;
                float b = v0.y-v1.y;
                float c = v0.z-v1.z;

                float d = v0.x-v2.x;
                float e = v0.y-v2.y;
                float f = v0.z-v2.z;

                vec3 p = cameraEye;
                vec3 q = rayDir;

                float g = q.x;
                float h = q.y;
                float i = q.z;
                float j = v0.x - p.x;
                float k = v0.y - p.y;
                float l = v0.z - p.z;
                float M = a*(e*i - h*f) + b*(g*f - d*i) + c*(d*h-e*g);
                float t = -(f*(a*k-j*b)+e*(j*c-a*l)+d*(b*l-k*c))/M;
                if (t <= 0.0 || t > rayEnd) {
                    continue;
                }
                float gamma = (i*(a*k-j*b)+h*(j*c-a*l)+g*(b*l-k*c))/M;
                if (gamma <= 0.0 || gamma >= 1.0) {
                    continue;
                }

                float beta = (j*(e*i-h*f)+k*(g*f-d*i)+l*(d*h-e*g))/M;
                if (beta <= 0.0 || beta >= (1.0 - gamma)) {
                    continue;
                }
                rayEnd = t;
                gl_FragColor = vec4(triangleColors[index], 1.0);
            } else if (renderMode == 2) {
                float a = v0.x-v1.x;
                float b = v0.y-v1.y;
                float c = v0.z-v1.z;

                float d = v0.x-v2.x;
                float e = v0.y-v2.y;
                float f = v0.z-v2.z;

                vec3 p = cameraEye;
                vec3 q = rayDir;

                float g = q.x;
                float h = q.y;
                float i = q.z;
                float j = v0.x - p.x;
                float k = v0.y - p.y;
                float l = v0.z - p.z;
                float M = a*(e*i - h*f) + b*(g*f - d*i) + c*(d*h-e*g);
                float t = -(f*(a*k-j*b)+e*(j*c-a*l)+d*(b*l-k*c))/M;
                if (t <= 0.0 || t > rayEnd) {
                    continue;
                }
                float gamma = (i*(a*k-j*b)+h*(j*c-a*l)+g*(b*l-k*c))/M;
                if (gamma <= 0.0 || gamma >= 1.0) {
                    continue;
                }

                float beta = (j*(e*i-h*f)+k*(g*f-d*i)+l*(d*h-e*g))/M;
                if (beta <= 0.0 || beta >= (1.0 - gamma)) {
                    continue;
                }
                rayEnd = t;
                vec3 normalColor = 0.5*(getNormal(v0,v1,v2) + vec3(1.0,1.0,1.0));
                gl_FragColor = vec4(normalColor, 1.0);
            }
        }
    }
</script>





<script>
    function initGui() {
        ["cameraEye", "cameraTarget", "cameraUp"].forEach(function (name) {
            ["X", "Y", "Z"].forEach(function (axis) {
                var selector = "#" + name + axis;
                $(selector).spinner({
                    min: -10.0,
                    max: 10.0,
                    step: 0.01,
                });
            });
        });
        $("#cameraFov").spinner({
            min: 1.0,
            max: 80.0,
            step: 1.0
        });
        ["lightPositionX", "lightPositionY", "lightPositionZ"].forEach(function (name) {
            $("#" + name).spinner({
                min: -10.0,
                max: 10.0,
                step: 0.01,
            });
        });
        ["lightIntensityR", "lightIntensityG", "lightIntensityB"].forEach(function (name) {
            $("#" + name).spinner({
                min: 0.0,
                max: 500.0,
                step: 0.01,
            });
        });
        ["backgroundColorR", "backgroundColorG", "backgroundColorB"].forEach(function (name) {
            $("#" + name).spinner({
                min: 0.0,
                max: 1.0,
                step: 0.01,
            });
        });
    }
    initGui();

    var renderModes = {
        "FACE_COLOR": 1,
        "NORMAL": 2,
        "SHADOW": 3,
        "FULL": 4
    };

    var scenes = createScenes();

    function setSceneGui(scene) {
        $("#cameraEyeX").spinner("value", scene.initialCamera.eye[0]);
        $("#cameraEyeY").spinner("value", scene.initialCamera.eye[1]);
        $("#cameraEyeZ").spinner("value", scene.initialCamera.eye[2]);

        $("#cameraTargetX").spinner("value", scene.initialCamera.target[0]);
        $("#cameraTargetY").spinner("value", scene.initialCamera.target[1]);
        $("#cameraTargetZ").spinner("value", scene.initialCamera.target[2]);

        $("#cameraUpX").spinner("value", scene.initialCamera.up[0]);
        $("#cameraUpY").spinner("value", scene.initialCamera.up[1]);
        $("#cameraUpZ").spinner("value", scene.initialCamera.up[2]);

        $("#cameraFov").spinner("value", scene.initialCamera.fov);

        $("#lightPositionX").spinner('value', scene.initialLight.position[0]);
        $("#lightPositionY").spinner('value', scene.initialLight.position[1]);
        $("#lightPositionZ").spinner('value', scene.initialLight.position[2]);

        $("#lightIntensityR").spinner('value', scene.initialLight.intensity[0]);
        $("#lightIntensityG").spinner('value', scene.initialLight.intensity[1]);
        $("#lightIntensityB").spinner('value', scene.initialLight.intensity[2]);
    }

    function getScene() {
        return scenes[$("#scene").val()];
    }

    $("#scene").change(function () {
        setSceneGui(getScene());
    });
    setSceneGui(getScene());

    function getRenderMode() {
        return renderModes[$("#renderMode").val()];
    }

    function getBackgroundColor() {
        return [
            $("#backgroundColorR").spinner("value"),
            $("#backgroundColorG").spinner("value"),
            $("#backgroundColorB").spinner("value")
        ];
    }

    function getCameraEye() {
        return [
            $("#cameraEyeX").spinner("value"),
            $("#cameraEyeY").spinner("value"),
            $("#cameraEyeZ").spinner("value")
        ]
    }

    function getCameraTarget() {
        return [
            $("#cameraTargetX").spinner("value"),
            $("#cameraTargetY").spinner("value"),
            $("#cameraTargetZ").spinner("value")
        ];
    }

    function getCameraUp() {
        return [
            $("#cameraUpX").spinner("value"),
            $("#cameraUpY").spinner("value"),
            $("#cameraUpZ").spinner("value")
        ];
    }

    function getCameraFov() {
        return $("#cameraFov").spinner("value")
    }

    function getLightPosition() {
        return [
            $("#lightPositionX").spinner("value"),
            $("#lightPositionY").spinner("value"),
            $("#lightPositionZ").spinner("value")
        ];
    }

    function getLightIntensity() {
        return [
            $("#lightIntensityR").spinner("value"),
            $("#lightIntensityG").spinner("value"),
            $("#lightIntensityB").spinner("value")
        ];
    }

    //
    // TODO: Fill you code here and elsewhere in the HTML.
    //
    function initializeWebGL(canvasName) {
        var canvas = $("#" + canvasName);
        // Getting WebGL context the right way
        var gl = null;
        try {
            gl = canvas[0].getContext("experimental-webgl");
            if (!gl) {
                gl = canvas[0].getContext("webgl");
            }
        } catch (error) {
            // NO-OP
        }
        if (!gl) {
            alert("Could not get WebGL context!");
            throw new Error("Could not get WebGL context!");
        }
        return gl;
    }

    function createShader(gl, shaderScriptId) {
        var shaderScript = $("#" + shaderScriptId);
        var shaderSource = shaderScript[0].text;
        var shaderType = null;
        if (shaderScript[0].type == "x-shader/x-vertex") {
            shaderType = gl.VERTEX_SHADER;
        } else if (shaderScript[0].type == "x-shader/x-fragment") {
            shaderType = gl.FRAGMENT_SHADER;
        } else {
            throw new Error("Invalid shader type: " + shaderScript[0].type)
        }
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            var infoLog = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error("An error occurred compiling the shader: " + infoLog);
        } else {
            return shader;
        }
    }

    function createGlslProgram(gl, vertexShaderId, fragmentShaderId) {
        var program = gl.createProgram();
        gl.attachShader(program, createShader(gl, vertexShaderId));
        gl.attachShader(program, createShader(gl, fragmentShaderId));
        gl.linkProgram(program);
        gl.validateProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            var infoLog = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error("An error occurred linking the program: " + infoLog);
        } else {
            return program;
        }
    }

    function runCanvas(canvasName, vertexShaderName, fragmentShaderName, prepareProgram) {
        var gl = initializeWebGL(canvasName);
        var program = createGlslProgram(gl, vertexShaderName, fragmentShaderName);

        var vertexData = [
            -1.0, -1.0, 0.0,  // Lower left
            0.0,  0.0,
            1.0, -1.0, 0.0,  // Lower right
            1.0,  0.0,
            1.0,  1.0, 0.0,  // Top right
            1.0,  1.0,
            -1.0,  1.0, 0.0,  // Top left
            0.0,  1.0
        ];
        var vertexArray = new Float32Array(vertexData);
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var indexData = [0, 1, 2, 0, 2, 3];
        var indexArray = new Uint16Array(indexData);
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        function updateWebGL() {
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            prepareProgram(gl, program);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var vertPositionLocation = gl.getAttribLocation(program, "vert_position");
            gl.enableVertexAttribArray(vertPositionLocation);
            gl.vertexAttribPointer(vertPositionLocation, 3, gl.FLOAT, false, 4*5, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            gl.useProgram(null);

            window.requestAnimationFrame(updateWebGL);
        }

        window.requestAnimationFrame(updateWebGL);
    }

    runCanvas("webglCanvas", "vertexShader", "fragmentShader", function(gl, program) {
        var rgb = getBackgroundColor();
        var colorLocation = gl.getUniformLocation(program, "color");
        // Step 2: Set its value using the right function.
        gl.uniform3f(colorLocation, rgb[0], rgb[1], rgb[2]);

        var cameraEyeLocation = gl.getUniformLocation(program, "cameraEye");
        var cameraEye = getCameraEye();
        gl.uniform3f(cameraEyeLocation, cameraEye[0], cameraEye[1], cameraEye[2]);

        var cameraUpLocation = gl.getUniformLocation(program, "cameraUp");
        var cameraUp = getCameraUp();
        gl.uniform3f(cameraUpLocation, cameraUp[0], cameraUp[1], cameraUp[2]);

        var cameraTargetLocation = gl.getUniformLocation(program, "cameraTarget");
        var cameraTarget = getCameraTarget();
        gl.uniform3f(cameraTargetLocation, cameraTarget[0], cameraTarget[1], cameraTarget[2]);

        var cameraFovLocation = gl.getUniformLocation(program, "cameraFov");
        var cameraFov = getCameraFov();
        gl.uniform1f(cameraFovLocation, cameraFov);

        var vertexPositionsLocation = gl.getUniformLocation(program, "vertexPositions[0]");
        var vertexPositions = getScene().vertexPositions;
        gl.uniform3fv(vertexPositionsLocation, vertexPositions);

        var triangleColorsLocation = gl.getUniformLocation(program, "triangleColors[0]");
        var triangleColors = getScene().triangleColors;
        gl.uniform3fv(triangleColorsLocation, triangleColors);

        var numOfTrianglesLocation = gl.getUniformLocation(program, "numOfTriangles");
        var numOfTriangles = getScene().triangleColors.length/3;
        gl.uniform1i(numOfTrianglesLocation, numOfTriangles);

        var renderModeLocation = gl.getUniformLocation(program, "renderMode");
        var renderMode = getRenderMode();
        gl.uniform1i(renderModeLocation, renderMode);
    });
</script>

</body>
</html>